# 主流MQ对比

目前主流的MQ有ActiveMQ, RabbitMQ, RocketMQ, Kafka。

|     | ActiveMQ                                                    | RabbitMQ                                                | RocketMQ                                                  | Kafka                                           |
|-----|-------------------------------------------------------------|---------------------------------------------------------|-----------------------------------------------------------|-------------------------------------------------|
| 优点  | 1. 成熟的产品，已经得到大规模应用，有较多的文档。<br />2. 各种协议支持较好，有多重语言的成熟客户端。    | 1. 社区活跃，管理页面很全面，支持插件式扩展功能。<br />2. 并发度高，延时低，适合吞吐量不大的情况。 | 1. 功能完备，可靠性高，源码为Java，可定制化。<br />2. 吞吐量大，性能非常好。            | 1. 社区活跃。<br />2. 吞吐量大                           |
| 缺点  | 1. 社区活跃度低，官方对ActiveMQ 5.x的维护越来越少。<br />2. 吞吐量较小，不适合上千队列的场景。 | 1. 因为是erlang语言开发，不能做定制化。<br />2. 集群不支持动态扩展。             | 1. 社区活跃度一般。<br />2. 产品文档比较缺乏。没有在MQ核心中去实现JMS等接口，对已有系统不能兼容。 | 1. 功能简单。<br />2. 由于topic数量对吞吐量的影响，建议吞吐量大的场景下使用。 |

# JAVA客户端

JAVA客户端有AMQP和JMS两种。

JMS 是 JEE 平台的标准消息传递 API。它可用于商业和开源实现。每个实现都包括一个 JMS 提供程序、一个 JMS
客户端库，以及用于管理消息传递系统的其他特定于实现的组件。JMS 提供者可以是消息服务的独立实现，也可以是非 JMS 消息系统的桥梁。

JMS 客户端 API 是标准化的，因此 JMS 应用程序可以在供应商的实现之间移植。但是，底层消息传递实现是未指定的，因此 JMS
实现之间没有互操作性。除非存在桥接技术，否则想要共享消息传递的 Java 应用程序必须全部使用相同的 JMS 实现。此外，如果没有特定于供应商的
JMS 客户端库来实现互操作性，非 Java 应用程序就无法访问 JMS。

AMQP 0-9-1 是一种消息传递协议，而不是像 JMS 这样的 API。任何实现该协议的客户端都可以访问支持 AMQP 0-9-1
的代理。协议级别的互操作性允许使用任何编程语言编写并在任何操作系统上运行的 AMQP 0-9-1 客户端参与消息传递系统，而无需桥接不兼容的供应商实现。

由于 JMS Client for RabbitMQ 是使用 RabbitMQ Java 客户端实现的，因此它符合 JMS API 和 AMQP 0-9-1 协议。

# 权限

# 核心概念

# 队列queue

## 属性

### durable

`durable = true`表示声明一个持久化的队列。服务器重启后，队列会重新生成。

### exclusive

`exclusive = true`表示声明一个专属队列。

专属的范围针对的是连接，也就是说，一个连接下面的多个信道是可见的。对于其他连接是不可见的。连接断开后，该队列会被删除。注意，不是信道断开，是连接断开。并且，就算设置成了持久化，也会删除。

### autoDelete

`autoDelete = true`
表示声明一个临时队列，服务器会在该队列“无使用”时，删除该队列，即使该队列中还有消息。等待删除的时间由`arguments`
中的`x-expires`可选参数控制。

> “无使用”：无消费者，也没有重新声明。

### arguments

#### x-expires

队列过期时间（`Numer`）。队列多长时间（毫秒，milliseconds）“无使用”，该队列将自动删除，和`autoDelete`结合使用。

> 官网建议，最好通过策略`expires`配置，可批量修改、避免删除队列。

`x-expires`参数和过期策略中的过期时间必须是**正数**。若`x-expires`有值，即使不设置`autoDelete = true`，过期时间到达后，队列也会删除。

> 消息过期`x-message-ttl`时间可以是0.

#### x-message-ttl

队列消息过期时间（`Numer`）。消息在**发布到队列**后，多长时间（毫秒，milliseconds）会自动删除。`x-message-ttl >= 0`。

> 官网建议，最好通过策略`message-ttl`配置，可批量修改、避免删除队列。

> 关于消息过期，可以查看[消息过期](#消息过期)一节。

#### x-dead-letter-exchange

死信交换机（Dead Letter Exchanges，简称DLX）（`String`），它是正常的交换机，可以是任何类型的交换机，声明方式和正常交换机相同。

> 官网建议，最好通过策略`dead-letter-exchange`配置，可批量修改、避免删除队列。

> 关于死信消息，可以查看[死信消息](#死信消息)一节。

#### x-dead-letter-routing-key

死信路由键（`String`），指定DLX路由到的队列。

> 官网建议，最好通过策略`dead-letter-routing-key`配置，可批量修改、避免删除队列。

> 关于死信消息，可以查看[死信消息](#死信消息)一节。

#### x-max-length

队列中`ready`状态消息的数量上限（`Numer`），消费者未确认消息不计入限制。到达上限后，默认会从头部开始丢弃消息，或是该消息变为死信消息。

> 官网建议，最好通过策略`max-length`配置，可批量修改、避免删除队列。

> 关于队列长度限制，可以查看[队列长度限制](#队列长度限制)一节。

#### x-max-length-bytes

队列中`ready`状态消息的消息体大小上限（`Numer`），单位时bytes。消费者未确认消息不计入限制，到达上限后，默认会从头部开始丢弃消息，或是该消息变为死信消息。

> 官网建议，最好通过策略`max-length-bytes`配置，可批量修改、避免删除队列。

> 关于队列长度限制，可以查看[队列长度限制](#队列长度限制)一节。

#### x-overflow

队列溢出行为。消息到达队列长度限制或消息体大小限制时，执行的操作。

> 官网建议，最好通过策略`overflow`配置，可批量修改、避免删除队列。

可选取值（`String`）：

- `drop-head`：从队列开头丢弃信息，若配置了DLX，则会死信消息。此为默认的溢出行为，不配置，则队列溢出行为就是`drop-head`。
- `reject-publish`：丢弃最新发布消息。发布者如果开启了发布确认，会收到`basic.nack`消息的拒绝通知。
- `reject-publish-dlx`：死信最新发布消息；

> 关于溢出行为，可以查看[队列溢出行为](#队列溢出行为)一节。

#### x-single-active-consumer

是否启用单一活跃消费者（`Boolean`）。允许一次只有一个消费者从队列中消费，并在活动消费者被取消或死亡的情况下故障转移到另一个注册消费者。

> 关于单一活跃消费者可以查看[单一活跃消费者](#单一活跃消费者)一节。

#### x-max-priority

队列支持的最大优先级数（`Number`）。如果未设置，队列将不支持消息优先级。

强烈建议使用 1 到 5（或10） 之间的值，该值与优先级队列资源占用直接相关。

> 关于优先级队列，可以查看[优先级队列](#优先级队列)一节。

#### x-queue-mode

队列模式。

> 官方建议，最好通过策略`queue-mode`配置，可批量修改、避免删除队列。
>
> 持久化队列、消息较大或较多的对立，建议选择`lazy`。

`x-queue-mode`取值（`String`）：

- `default`：默认模式，消息发布到队列时，保存在RAM中，如果队列设置为持久化（`durable = true`），则也会保存在磁盘上。
- `lazy`：惰性队列，消息发布到队列时，保存到磁盘上。

将队列设置为惰性模式，在磁盘上保留尽可能多的消息以减少 RAM 使用；如果未设置，队列将保留内存缓存以尽快传递消息。当队列中的消息量可能很大时，建议将队列设置为惰性队列。

> 关于队列模式，可以查看[惰性队列](#惰性队列)一节。

#### x-queue-version

队列版本。配置文件`rabbitmq.conf`文件中指定默认版本，默认为版本`1`。

> 官方建议，最好通过策略`queue-version`配置，可批量修改、避免删除队列。
>
>  建议使用版本`2`，可以提升性能。

取值范围（`Number`）：

- `1`：有一个嵌入小消息的基于日志的索引；
- `2`： 有一个新的索引文件格式和实现，以及一个新的队列存储文件格式来取代消息直接嵌入索引，可以提高许多场景中的内存使用和性能。

> 关于队列版本，可以查看[经典队列持久化](#经典队列持久化)一节。

#### x-master-locator

指定队列的leader节点选择方式。

> 官方建议，最好通过策略`queue-master-locator`配置，可批量修改、避免删除队列。

取值范围（`String`）：

- `balanced`：选择托管相同队列类型、leader副本最少的节点；
- `client-local`：选择客户端申明队列时，连接的节点；

> 关于队列leader节点选择方式，以及队列镜像（经典队列不要使用，推荐[仲裁队列](#仲裁队列)
> ），可以查看[经典队列镜像](#经典队列镜像)一节。

## 队列长度限制

[Queue Length Limit — RabbitMQ](https://www.rabbitmq.com/maxlength.html)

队列的长度限制可以通过2个方面限制：

1. 消息数量：队列中消息的总数量；
2. 消息体大小：队列中所有消息正文长度额总和，忽略消息属性和任何开销；

队列长度限制统计的队列消息包括`ready`状态的消息，消费者未确认的消息不在统计范围内。另外，设置每条消息TTL时，消息数量统计会包含已过期，但未丢弃的消息。

对于任何给定的队列，配置队列长度限制的方式有了两种：

- 使用策略`max-length`, `max-length-bytes`配置。强烈推荐此选项。
- 使用队列的可选参数`x-max-length`, `x-max-length-bytes`来定义最大长度。

**注意：**

在有效队列策略和参数都指定最大长度的情况下，将使用这两个值中的最小值。

队列长度设置也可以由operator policy强制执行。

## 队列溢出行为

当消息到达队列设置的数量限制或消息体长度限制时，队列会执行设置的溢出行为（overflow behaviour）。默认的溢出行为是从队列开头丢弃或死信消息。

溢出行为可以通过以下方式配置：

- 策略`overflow`。建议使用该方式；
- 队列可选参数`x-overflow`。

溢出行为可以配置为以下操作：

- `drop-head`：从队列开头丢弃信息，若配置了DLX，则会死信消息。此为默认的溢出行为，不配置，则队列溢出行为就是`drop-head`。
- `reject-publish`：丢弃最新发布消息。发布者如果开启了发布确认，会收到`basic.nack`消息的拒绝通知。
- `reject-publish-dlx`：死信最新发布消息；

仲裁队列（quorum queue）只支持`drop-head`和`reject-publish`。

## 优先级队列

[Priority Queue Support — RabbitMQ](https://rabbitmq.com/priority.html)

RabbitMQ 为经典队列提供了优先级队列实现。

**优先级队列设置**：

- 使用队列的可选参数`x-max-priority`，任何队列都可以变成优先队列；若不声明，则不支持优先级队列；
- 不支持使用策略声明优先级；
- 该实现支持有限数量的优先级：255。强烈建议使用 1 到 5（或10） 之间的值，该值与优先级队列资源占用直接相关。

**消息优先级设置**：

- 通过`propeties`设置`priority`，如`message.getMessageProperties().setPriority(1);`；
- 数字越大，优先级越高；
- 没有设置优先级的消息，默认优先级为`0`；超过队列设置的优先级最大值，则该消息优先级被视为最大值。

**优先级队列消费者**：

默认情况下，消费者监听一个空队列时，消息发布到该队列后，会被消费者立即消费，无法进行优先级排序。

在消费者的手动确认模式下使用`basic.qos`方法，以限制随时可以发送的消息数量，从而使消息具有优先级。

**注意**：

- 优先级队列具有RabbitMQ普通队列的所有特性；
- 优先级队列过期消息仍然只会从队列头部开始过期；且因为优先级排序，可能会导致过期的低优先级消息卡在未过期的高优先级消息之后，这些过期的低优先级消息会出现在队列统计信息中；
- 具有最大长度限制的优先级队列，会和普通队列一样从头部丢弃信息（默认`drop-head`），可能会导致高优先级的消息被丢弃。

## 仲裁队列

仲裁队列是一种更高级的队列类型，利用副本和专注数据安全性，提供了高可用性。基于Raft一致性算法实现可持久化、可复制的FIFO队列。

从RabbitMQ
3.10开始，仲裁队列支持消息TTL，与经典镜像队列相比，提供更高的吞吐量和更稳定的延迟。经典镜像队列可以[迁移到仲裁队列](#经典队列迁移)
。队列复制应该使用仲裁队列或者流，而经典队列将只提供非复制的队列类型。

对于需要复制和可重复读取的情况，[流](#Stream数据结构)可能是比仲裁队列更好的选择。

### 与经典队列的区别

RabbitMQ中的经典镜像队列具有技术局限性，因此很难提供方便的故障处理。某些故障情况可能会导致镜像队列过早地确认消息，进而导致数据丢失。

仲裁队列和其他类型队列的基本属性相似，客户端基本都能支持仲裁队列。

**相同点**：

- 消费（订阅）；
- 消费者确认（全局`QoS`和`prefetch`除外）；
- 取消消费者；
- 清空（purge）;
- 删除；

**不同点**：

- 声明；
- 消费者设置`prefetch`;

| 特点             | 经典镜像队列       | 仲裁队列                                               |
|----------------|--------------|----------------------------------------------------|
| 非持久化队列         | 支持 &#10004;  | 不支持 &#10006;                                       |
| 独占队列           | 支持 &#10004;  | 不支持 &#10006;                                       |
| 每条消息持久化        | 每条消息设置       | 总是 &#10004;                                        |
| 成员关系变化         | 自动           | 手动                                                 |
| 消息过期           | 支持 &#10004;  | 支持 &#10004;（3.10 +）                                |
| 队列过期           | 支持 &#10004;  | 队列重新声明时过期时间不刷新                                     |
| 队列长度限制         | 支持 &#10004;  | 支持 &#10004;（不支持`x-overflow`: `reject-publish-dlx`） |
| 惰性队列           | 支持 &#10004;  | 总是  &#10004;（3.10 +）                               |
| 消息优先级          | 支持 &#10004;  | 不支持 &#10006;                                       | 
| 消费者优先级         | 支持 &#10004;  | 支持 &#10004;                                        |
| 死信交换机          | 支持 &#10004;  | 支持 &#10004;                                        |
| 策略             | 支持 &#10004;  | 支持 &#10004;（[仲裁队列策略](#仲裁队列策略)）                     |
| 有毒消息处理         | 不支持 &#10006; | 支持 &#10004;                                        |
| 全局QoS/prefetch | 支持 &#10004;  | 不支持 &#10006;                                       |

### 经典队列迁移

### 仲裁队列策略

## 惰性队列

[Lazy Queues — RabbitMQ](https://www.rabbitmq.com/lazy-queues.html)

在惰性模式下运行的经典队列，会尽可能早地将其内容移动到磁盘，并且仅在消费者请求时才将它们加载到 RAM 中，因此称为惰性队列。

默认情况下，队列保留一个内存中的消息缓存，当消息发布到 RabbitMQ 时该缓存会被填满。这个缓存的想法是能够尽快将消息传递给消费者。请注意，持久消息可以在进入代理时写入磁盘并同时保存在
RAM 中。

每当代理认为它需要释放内存时，来自该缓存的消息将被分页到磁盘。将一批消息分页到磁盘需要时间并阻塞队列进程，使其在分页时无法接收新消息。尽管最新版本的
RabbitMQ 改进了分页算法，但对于队列中有数百万条消息可能需要分页的用例，情况仍然不理想。

惰性队列试图尽可能早地将消息移动到磁盘。这意味着在大多数情况下，在正常操作下，RAM 中保存的消息要少得多。这是以增加磁盘 I/O
为代价的。

> 另外，服务器配置`queue_index_embed_msgs_below`设置为0，关闭队列索引负载嵌入，会使得消息只保存在磁盘上。



在 RabbitMQ 3.12 之前，经典队列可以在惰性模式下运行。从 RabbitMQ 3.12
开始，队列模式被忽略，经典队列的行为方式与惰性队列类似。然而，他们可能会根据消费率在内存中保留少量消息（最多 2048
条，具体数量和版本相关）。

建议 RabbitMQ 3.11 及以下版本的用户升级到 RabbitMQ 3.12 或**启用惰性模式**以避免遇到内存问题。当保持低节点内存使用率是优先事项并且可以接受更高的磁盘
I/O 和磁盘利用率时，惰性队列是合适的。惰性队列还有其他应该考虑的方面。

惰性队列的主要目标之一是能够支持非常长的队列（数百万条消息）。由于各种原因，队列可能会变得很长：

- 消费者离线/崩溃/停机维护；
- 突然出现消息入口峰值；
- 生产者超过了消费者；
- 消费者比平时慢；

### 队列模式配置

队列模式配置方法：

- 通过策略`queue-mode = lazy`，设置队列模式为惰性队列。建议采用此种方式；
- 通过队列可选参数`x-queue-mode = lazy`，设置队列模式为惰性对立；

当有效策略和队列可选参数都设置了队列模式时，队列参数的优先级更高。

队列模式取值：

- `default`：默认模式，消息发布到队列时，保存在RAM中，如果队列设置为持久化（`durable = true`
  ），则也会保存在磁盘上。如果队列声明，未指定队列模式时，或无有效队列模式策略时，队列模式为`default`，此默认配置从RabbitMQ
  3.6.0版本开始存在。
- `lazy`：惰性队列，消息发布到队列时，保存到磁盘上。

### 队列模式切换

通过策略可以动态修改队列模式。

将默认队列转换为惰性队列时，对操作的性能影响与队列需要将消息分页到磁盘时的影响相同。在从默认模式转换为惰性模式期间，队列首先将保存在
RAM 中的所有消息分页到磁盘。当该操作正在进行时，它不会再接受来自发布渠道的任何消息。完成初始页调出后，队列将开始接受发布、确认和其他命令。

当一个队列从惰性模式进入默认模式时，它会执行与服务器重启后队列恢复时相同的过程：将一批 16384 条消息加载到内存中。

## 持久化

### 经典队列持久化

经典队列有两种存储方式：

- 版本1（原始版本）：有一个嵌入小消息的基于日志的索引；
- 版本2（RabbitMQ 3.10以上版本支持）：有一个新的索引文件格式和实现，以及一个新的队列存储文件格式来取代消息直接嵌入索引，可以提高许多场景中的内存使用和性能。

从 RabbitMQ 3.10.0 开始，broker
有一个新的经典队列实现，命名为“版本2”。版本2的队列有一个新的索引文件格式和实现，以及一个新的队列存储文件格式来取代消息直接嵌入索引，主要改进是在高内存压力下提高了稳定性。RabbitMQ
3.10.0中，默认的队列版本是版本1。

#### 队列版本配置

- 策略`queue.version`指定队列版本。建议使用此种方式。
- 队列可选参数`x-queue-version`指定队列版本。
- 可以在`rabbitmq.conf`文件中的`classic_queue.default_version`中指定默认的队列版本取值。

可以使用策略`queue.version`更改版本。通过策略设置新版本时，队列将立即转换其磁盘上的数据。可以升级到版本2或降级到版本1。请注意，对于大型队列，转换可能需要一些时间，并导致在转换运行时队列不可用，建议。

#### 消息持久化层

持久化消息和瞬时（transient，可译为暂存、临时、瞬时，表示非持久化）消息都会保存到磁盘上，区别在于：

- 持久化消息刚进入队列，就会保存到磁盘上；
- 瞬时消息，只有当消息因为内存压力被逐出内存时，才会持久化到磁盘上。

此处持久化的队列指的是一个队列的持久化，而不是“队列镜像（queue mirroring）”，队列镜像是一种更高层的持久化。

**持久化层有两个组件**：

- **队列索引**（rabbit_queue_index）：队列索引负责维护落盘消息存储位置，以及消息是否投递和确认的信息。因此，每个队列都有一个队列索引。
- **消息存储**
  （rabbit_msg_store）：消息存储是消息的键值存储，在每个虚拟主机中的所有队列之间共享。消息（正文和任何元数据字段：属性和/或标头）可以直接存储在队列索引中，也可以写入消息存储。技术上有两种消息存储（一种用于瞬时消息，一种用于持久消息），但通常将它们一起视为“消息存储”。

在内存压力下，持久化层会尽可能地将消息写入磁盘、移出内存，但是仍然有一些数据必须保留在内存中：

- 每个队列未确认消息的一些元数据。如果消息本身存储在消息存储中，那么消息本身会从内存中删除；
- 消息存储需要的索引。默认会使用少量的内存，保存消息存储中每条消息的索引。

#### 消息嵌入队列索引

**消息嵌入队列索引的优缺点**：

**优点**：

- 消息只需要一次写入磁盘操作，对于短消息，性能提升很大；
- 嵌入队列索引中的消息，不需要在消息存储中的保存，因此，当消息从内存中扇出时，不需要多余的内存消耗。

**缺点**：

- 队列索引在内存中的数量固定不变，如果将消息嵌入队列索引中，那么内存占用可能会很大；
- 如果消息路由到多个队列，消息嵌入到队列索引中，会导致消息被写入多个队列索引中。如果消息被写入消息存储中，那么消息只会写入一次；
- 未确认的嵌入队列索引的消息，会永久保存在内存中；
- 当使用队列版本2时，二次写入操作仍会发生。

目的是将短消息存入队列索引中，并将所有其他消息存入消息存储中的优化，可以通过配置项`queue_index_embed_msgs_below`
控制。默认情况下，序列化后的消息长度小于4096个字节（包含属性和头部信息），则会被存储到队列索引中。

每个队列索引在从磁盘读取消息时需要在内存中保留至少一个段文件。段文件包含 16,384
条消息的记录。因此，如果增加`queue_index_embed_msgs_below`，请谨慎；少量增加会导致大量内存使用。

## 经典队列镜像

[Classic Queue Mirroring — RabbitMQ](https://www.rabbitmq.com/ha.html)

**注意**：经典队列镜像（queue mirroring）是已经被弃用且计划删除的功能，替代方案是[仲裁队列](#仲裁队列)（Quorum queue）。

**下面只是介绍经典队列镜像，但是不建议使用经典队列镜像。**

经典队列的可选参数`x-queue-version = 2`可以和镜像一起使用。但是不建议合并v1和v2队列，v2队列中的数据可能会使得v1队列过载，建议先将v1队列利用策略转换成v2队列。

### 什么是队列镜像

**小结**：

- 默认情况，queue存在于申明队列的节点上，exchange和binding存在于所有节点上；
- 开启队列镜像后，所有镜像都会同步leader，无论连上哪个节点，除发布之外的所有操作都是先应用到leader节点，再传播到镜像；
- 开启队列镜像后，leader节点故障后，最老的镜像会成为leader，也可以指定其他未同步的镜像。

### 队列镜像配置

##### 开启队列镜像

对于某些只有瞬时消息的队列、非持久队列、独占队列，不需要开启队列镜像（独占队列无法镜像）。

只能通过策略开启队列镜像，当队列的HA策略发生变化时，RabbitMQ会尽量保留现有的镜像：

1. `ha-mode = exactly, ha-params = ${count}`：集群中的副本数（leader + mirror）。建议镜像到集群节点数量的`n/2 + 1`。
2. `ha-mode = all `：在集群的所有节点上进行镜像。这会增加节点压力。
3. `ha-mode = nodes, ha-params = [nodeNames, ...]`：队列被镜像到指定节点名称的节点上。

另外可以指定镜像同步的方式：

`ha-sync-mode`:

#### leader节点

为了使得队列leader副本不集中在少部分节点上，可以让不同队列的leader节点不同，以减少节点压力。

leader节点配置方法：

- 策略`queue-master-locator`；建议使用此种方法。
- 队列可选参数`x-queue-master-locator`;
- 配置文件`queue_leader_locator`。

取值（`String`）:

- `balanced`：选择托管相同队列类型、leader副本最少的节点；
- `client-local`：选择客户端申明队列时，连接的节点；

### leader故障转移

若是未开启队列镜像，队列将仅存在于leader节点。

- leader节点可用时，连接任一节点都会将操作路由的leader节点；
- leader节点故障时，持久化队列需要等待leader节点恢复，才能进行操作；非持久化队列会被删除。

leader故障，镜像会被提升为leader：

- 最老的节点会被提升为leader。若是该节点未完全同步原leader，则会丢失部分消息；
- 镜像会将已经传递给客户端但是没有确认（`Unacked`）的消息重新排队，即使客户端已发出确认，但是未同步到镜像；这可能会导致消费者的重复消费；
- 消费者在故障转移时的请求，会收到取消通知；
- 镜像在提升为leader的过程中，生产者发布的消息不会丢失，客户端发布确认也会得到确认。因为消息的发布会发布到所有节点上，镜像提升为leader后，会同步所有节点的消息；

如果消费者以`autoAck`（此处的RabbitMQ `autoAck`和spring-amqp中的`AcknowledgeMode.AUTO`
不同，其为broker发出后自动ack，等于spring-amqp中的`AcknowledgeMode.NONE`
）模式连接broker，那么消费者突然断开时，原leader发出的消息可能用户不会被消费者接收到，新的leader也无法将这些消息重新排队。

### 发布确认和事务

镜像队列支持发布确认和事务。

只有消息成功发布到所有镜像上，或事务成功应用到所有镜像上，才会返回成功给发布确认和事务提交。

### leader故障和消费者断开

消费者监听队列时，可能期望知道leader发生了故障转移。当队列发生故障转移时，已发送的消息可能会丢失，因此所有未确认的消息都将重新投递并设置重新投递标识。

可以通过设置消费者的`x-cancel-on-ha-failover`为`true`
，然后消费者消费将会在发生故障转移时被取消，并发送“消费者取消通知”。消费者有责任重新发送`basic.consume`以重新消费。

# 消息

## Header

`CC`：抄送。

`BCC`：加密操作。

## 消息过期

[Time-To-Live and Expiration — RabbitMQ](https://rabbitmq.com/ttl.html)

消息过期后，会成为[死信消息](#死信消息)，服务器来保证死信消息不会发送给消费者。另外，服务器将在消息到期后，立刻尝试删除消息。

### 配置

设置消息过期的方式有2种（建议通过策略方式配置）：

1. 每个队列消息过期（per-queue message TTL）：以队列为单位的消息过期。有2中配置方式：
    1. 通过队列可选参数`x-messaget-ttl`配置；
    2. 通过策略`message-ttl`配置。
2. 每条消息过期（per-message TTL）：以消息为单位的消息过期。每条消息过期时间属性`expiration`
   。范例`message.getMessageProperties().setExpiration("60000");`，注意时间长度为**字符串**。不同过期时间的消息，发布到同一个队列可能会导致消息阻塞。

### 注意

- 当**有效策略**、**队列可选参数**、**消息属性**都设置了消息过期时间时，消息的过期取三者中的最小值。

- 消息过期时间必须`>= 0`。将 TTL 设置为0会导致消息在到达队列后过期，除非它们可以立即传递给消费者。因此，这提供了
  RabbitMQ3.0以前服务器不支持的`immediate`标志的替代方案。与`immediate`标志不同的是，没有`basic.returns`
  被发出，如果设置了死信交换，那么消息将是死信的。

- 对于给已存在消息的队列应用队列消息过期策略，需要注意一些问题：

    - 只有当过期消息到达队列头部时，它们才会真正被丢弃（或死信）。消费者不会收到过期的消息。

    - 设置每条消息 TTL 过期消息时，可以在未过期消息之后排队，直到后者被消耗或过期。此类过期消息使用的资源将不会被释放，并且它们将被计入队列统计信息（例如队列中的消息数）。

    - 当追溯应用每条消息的 TTL 策略时，建议让消费者在线以确保更快地丢弃消息。

    - 考虑到现有队列上每条消息 TTL 设置的这种行为，当需要删除消息以释放资源时，应该改用队列 TTL（或队列清除或队列删除）。

## 死信消息

[Dead Letter Exchanges — RabbitMQ](https://rabbitmq.com/dlx.html)

队列中的消息可以成为“死信消息”（`dead letter`），死信消息无法被正常消费。若是队列配置了死信交换机，死信消息则会被发布到该交换机中。

队列中的消息成为“死信消息”的事件：

1. 消费者拒绝消息，并不重新发布消息。消费者使用`basic.reject`或`basic.nack`,将`requeue`设置为`false`；
2. 消息过期。队列消息过期（队列的`x-message-ttl`，或队列有效策略的`message-ttl`
   ）、单条消息过期（`Messaget.getProperties().getExpiration()`）；
3. 队列超过了长度限制，消息被丢弃；
4. 消息重新投递次数过多，超过策略限制。

> 注意：
>
> 队列过期（`x-expires`）,不会使队列中的消息成为死信消息。

### 配置死信路由

**死信交换机和死信路由键配置**：

- 策略`dead-letter-exchange`, `dead-letter-routing-key`。建议通过策略方式配置。
- 队列可选参数`x-dead-letter-exchange`, `x-dead-letter-routing-key`;

**配置DLX需注意**：

- 在有效策略和队列可选参数都配置了DLX，队列可选参数的优先级更高。建议通过策略方式配置；

- 队列的DLX，必须和该队列在同一虚拟主机（`virtual-host`）下；
- 在声明队列时，队列配置的DLX不必存在，但是若是有消息成为死信消息时，DLX不存在，或路由到的队列不存在，该死信消息则会被丢弃；仲裁队列（quorum
  queue）支持死信消息再次投递时，开启发布确认；
- 指定死信交换后，除了对该声明队列的配置权限外，用户还需要对该队列具有读取权限和对死信交换机具有写入权限。权限在队列、交换机声明时进行验证。

**死信消息路由方式**：

- 若配置了死信路由键，则通过DLX路由到指定队列；
- 若未配置死信路由键，则会使用消息最开始发布的路由键；

> 当路由配置导致死信消息循环投递，形成消息死信循环，且整个循环内没有拒绝操作（例如单纯的多个队列消息过期后，死信路由循环）时，两次到达同一队列的消息会被丢弃。

### 消息死信的影响

消息死信后，其头部信息（`headers`）会被修改：

- 交换机名称会被修改为最新的DLX（死信交换机）；
- 路由键可能会被修改为指定的死信路由键；
- `CC`, `BCC`头部会被去除；
- 添加首次死信消息产生的相关信息，添加后不会被修改：
    - `x-first-death-reason`；
    - `x-first-death-queue`；
    - `x-first-death-exchange`;
- 添加名为`x-death`的头部数组;

**`x-death`数组说明**：

`x-death`由一对{`queue`, `reason`}标识。由以下几个字段组成：

- `queue`：消息死信前所在队列名称；
- `reason`：消息死信的原因；可能的取值有以下几种情况：
    - `rejected`：消费者拒绝消息，并且`requeue = false`；
    - `expired`：消息过期；
    - `maxlen`：超过队列长度限制；
    - `delivery_limit`：消息被重新投入队列次数过多（通过策略限制）。
- `time`：消息死信的时间，时间格式是时间戳（秒）；
- `exchange`：消息发布的交换机名称；
- `routing-keys`：消息发布的路由键，包括header中的`CC`路由键，但不包括`BCC`的路由键；
- `count`：该消息在该队列和该原因下，死信的次数；
- `original-expiration`：如果消息是由于消息自身过期时间(per-message TTL)
  到达，而成为死信消息，那么消息本身的过期时间属性将会被移除，以免被路由到其他队列后，再次由于消息自身属性而过期。

`x-death`数组新条目会添加到数组的开头，如果已经包含相同{`queue`, `reason`}条目，则会增加`count`
字段，并将该条目移动到数组开头。因此，最新的死信相关信息会记录在`x-death`数组第一个条目中。

# 策略policy

// todo

[Parameters and Policies — RabbitMQ](https://rabbitmq.com/parameters.html#policies)

RabbitMQ 支持的某些协议中的客户端控制属性通常运行良好，但它们可能不灵活：更新 TTL
值或镜像参数需要应用程序更改、重新部署和队列重新声明（涉及删除）。此外，无法控制队列和交换器组的额外参数。针对上述痛点，可使用`policy`
解决。

`policy`按名称匹配一个或多个队列（使用正则表达式模式）并将其定义（可选参数的映射）附加到匹配队列的 x 参数。换句话说，可以使用策略一次为多个队列配置
x 参数，并通过更新策略定义一次更新它们。

# Stream数据结构

# 消费者

[Consumers — RabbitMQ](https://rabbitmq.com/consumers.html)

## 单一活跃消费者

[Single Active Consumer](https://rabbitmq.com/consumers.html#single-active-consumer)

单一活跃消费者（Single Active Consumer，简称SAC），允许一次**只有一个消费者**
从队列中消费，并在活动消费者被取消或死亡的情况下故障转移到另一个注册消费者。当消息必须按照它们到达队列的**相同顺序**
被消费和处理时，只允许一个消费者是有用的。

与`exclusive`消费者相比，单一活跃消费者对应用端维持消费连续性的压力更小。消费者只需要注册并自动处理故障转移，无需检测活动消费者故障并注册新消费者。

**典型的事件序列如下**：

- 队列被声明，并且一些消费者大致在同一时间注册到它；
- 第一个注册的消费者成为单一活跃消费者：消息被发送给它，其他消费者被忽略；
- 单个活跃消费者由于某种原因被取消或干脆死亡。其中一个已注册的消费者成为新的单一活跃消费者，并且消息现在被发送给它。换句话说，队列自动故障转移到另一个消费者。

请注意，如果不启用单个活动消费者功能，消息将**循环分发**给所有消费者。

**配置方法**：

- 声明队列时，设置可选参数`x-single-active-consumer = true`。

**注意**：

- 无法指定活跃消费者，它是随机选择的；
- 若队列可选参数设置了`x-single-active-consumer = true`，那么设置队列属性`exclusive = true`会报错，两者互斥；
- 设置单一活跃消费者，可能会导致某个消费过于繁忙；
- 无法通过策略启用单个活跃消费者，因为单一活跃消费者的机制与策略的动态设置的特点相悖。

## 消费者优先级

消费者优先级可以确保高优先级消费者在“**活跃**”时接收消息，而高优先级消费者阻塞时，消息会发送给较低优先级的消费者。

通常，连接到队列的活动消费者以循环方式从队列接收消息。当使用消费者优先级时，如果存在多个具有相同高优先级的活动消费者，则消息将循环传递。

“**活跃消费者**”是指无需等待即可接收消息的消费者。阻塞的消费者可能是因为`qos`或者网络不稳定。


