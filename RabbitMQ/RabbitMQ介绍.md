# 主流MQ对比

目前主流的MQ有ActiveMQ, RabbitMQ, RocketMQ, Kafka。

|      | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 1. 成熟的产品，已经得到大规模应用，有较多的文档。<br />2. 各种协议支持较好，有多重语言的成熟客户端。 | 1. 社区活跃，管理页面很全面，支持插件式扩展功能。<br />2. 并发度高，延时低，适合吞吐量不大的情况。 | 1. 功能完备，可靠性高，源码为Java，可定制化。<br />2. 吞吐量大，性能非常好。 | 1. 社区活跃。<br />2. 吞吐量大                               |
| 缺点 | 1. 社区活跃度低，官方对ActiveMQ 5.x的维护越来越少。<br />2. 吞吐量较小，不适合上千队列的场景。 | 1. 因为是erlang语言开发，不能做定制化。<br />2. 集群不支持动态扩展。 | 1. 社区活跃度一般。<br />2. 产品文档比较缺乏。没有在MQ核心中去实现JMS等接口，对已有系统不能兼容。 | 1. 功能简单。<br />2. 由于topic数量对吞吐量的影响，建议吞吐量大的场景下使用。 |

# JAVA客户端

JAVA客户端有AMQP和JMS两种。

JMS 是 JEE 平台的标准消息传递 API。它可用于商业和开源实现。每个实现都包括一个 JMS 提供程序、一个 JMS 客户端库，以及用于管理消息传递系统的其他特定于实现的组件。JMS 提供者可以是消息服务的独立实现，也可以是非 JMS 消息系统的桥梁。

JMS 客户端 API 是标准化的，因此 JMS 应用程序可以在供应商的实现之间移植。但是，底层消息传递实现是未指定的，因此 JMS 实现之间没有互操作性。除非存在桥接技术，否则想要共享消息传递的 Java 应用程序必须全部使用相同的 JMS 实现。此外，如果没有特定于供应商的 JMS 客户端库来实现互操作性，非 Java 应用程序就无法访问 JMS。

AMQP 0-9-1 是一种消息传递协议，而不是像 JMS 这样的 API。任何实现该协议的客户端都可以访问支持 AMQP 0-9-1 的代理。协议级别的互操作性允许使用任何编程语言编写并在任何操作系统上运行的 AMQP 0-9-1 客户端参与消息传递系统，而无需桥接不兼容的供应商实现。

由于 JMS Client for RabbitMQ 是使用 RabbitMQ Java 客户端实现的，因此它符合 JMS API 和 AMQP 0-9-1 协议。

# 核心概念

// todo

# 队列queue

